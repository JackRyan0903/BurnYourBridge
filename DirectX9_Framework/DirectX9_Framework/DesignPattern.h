

/*=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=*/
/* @author    정성화
/* @e-mail    JackRyan0903@gmail.com
/* @Copyright 2015년 1월 1일 목요일  오후 9:32:00. Jack Ryan all rights reserved.
/*=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=*/

#pragma once
/*=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=*/
/*  @포함
/*=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=*/
#include <memory>		//	std::shared_ptr

//================================================================================//
//  @네임스페이스
//  @포함 패턴 
//      1. 싱글톤 패턴(CSingleton)
//================================================================================//
namespace DesignPattern{

    template<typename T>
    class CSingleton
    {
    public:
        CSingleton(){}
        ~CSingleton(){}

		//================================================================================//
        //  @멤버 함수
        //  @설명 : 멤버변수로 가지고 있는 클래 스객체 스마트 포인터가 nullptr일 경우 새로 생성 후 반환,
        //          그렇지 않다면 원래 가지고 있던 클래스 객체 스마트 포인터를 반환.
		//================================================================================//
        static T* getInstancePtr(){

            if( nullptr == m_cpInstance ){
                m_cpInstance.reset(new T);
            }

            return m_cpInstance.get();
        }

    private:
        static std::shared_ptr<T> m_cpInstance;
    };

    template<typename T> std::shared_ptr<T> CSingleton<T>::m_cpInstance = nullptr;

};

